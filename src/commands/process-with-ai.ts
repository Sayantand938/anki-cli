// src/commands/process-with-ai.ts
import { Command, Option } from 'commander';
import fs from 'fs-extra';
import path from 'path';
import chalk from 'chalk';
import { z } from 'zod';
import { GoogleGenAI } from '@google/genai';
import spinners from 'cli-spinners';

import { logger } from '../utils/logger.js';
import { DATA_DIR, INSTRUCTIONS_DIR } from '../config/paths.js';
import { AI_SYSTEM_PROMPT, MAX_ITEMS_PER_CHUNK, MAX_RETRIES } from '../config/ai.js';
import { INPUT_JSON_FILENAME, RETRY_DELAY_MS, TRACKER_FILENAME } from '../config/app.js';
import { writeJsonFile } from '../utils/file-utils.js';
import { delay } from '../utils/timers.js';

const NoteSchema = z.object({
  noteId: z.number(),
  SL: z.string(),
  Question: z.string(),
  OP1: z.string(),
  OP2: z.string(),
  OP3: z.string(),
  OP4: z.string(),
  Answer: z.string(),
  Extra: z.string(),
  Tags: z.array(z.string()),
});
const NotesSchema = z.array(NoteSchema);
type Note = z.infer<typeof NoteSchema>;

const ai = new GoogleGenAI({});
const TRACKER_FILE = path.join(DATA_DIR, TRACKER_FILENAME);
type Tracker = { processed: string[]; failed: string[] };

const validateEnv = () => {
  if (!process.env.GEMINI_API_KEY) throw new Error('GEMINI_API_KEY is not set.');
};

const readJsonInput = async (): Promise<Note[]> => {
  const inputFilePath = path.join(DATA_DIR, INPUT_JSON_FILENAME);
  try {
    const raw = await fs.readJson(inputFilePath);
    return NotesSchema.parse(raw);
  } catch (error: any) {
    if (error.code === 'ENOENT') throw new Error(`[FAIL] ${INPUT_JSON_FILENAME} is not present`);
    if (error instanceof z.ZodError) {
      const issues = error.errors.map(e => `  - Path: ${e.path.join('.')}, Message: ${e.message}`).join('\n');
      throw new Error(`[FAIL] Zod validation failed for ${INPUT_JSON_FILENAME}:\n${issues}`);
    }
    throw error;
  }
};

const readInstruction = async (filename: string): Promise<string> =>
  fs.readFile(path.join(INSTRUCTIONS_DIR, filename), 'utf-8');

const buildUserPrompt = (chunkPath: string, content: string, instruction: string): string => `
<file_contents>
File: ${chunkPath}
\`\`\`json
${content.trim()}
\`\`\`

File: ${path.join(INSTRUCTIONS_DIR, '...')}
\`\`\`markdown
${instruction.trim()}
\`\`\`
</file_contents>`;

const splitChunks = async (notes: Note[]): Promise<string[]> => {
  const partPaths: string[] = [];
  for (let i = 0; i < notes.length; i += MAX_ITEMS_PER_CHUNK) {
    const chunk = notes.slice(i, i + MAX_ITEMS_PER_CHUNK);
    const partPath = path.join(DATA_DIR, `input-part-${partPaths.length + 1}.json`);
    await writeJsonFile(partPath, chunk);
    partPaths.push(partPath);
  }
  return partPaths;
};

const getAiCompletion = async (systemPrompt: string, userPrompt: string): Promise<string> => {
  const response = await ai.models.generateContent({
    model: 'gemini-2.5-flash',
    contents: `${systemPrompt}\n\n${userPrompt}`,
    config: { thinkingConfig: { thinkingBudget: -1 } },
  });
  if (!response.text) throw new Error('Empty response from Gemini API');
  return response.text;
};

const extractJsonFromResponse = (text: string): any => {
  const match = text.match(/```json\n([\s\S]*?)\n```/);
  if (!match?.[1]) throw new Error('No valid JSON code block found');
  return JSON.parse(match[1]);
};

/**
 * Validates that no object in the array has empty string values for any of its properties,
 * ignoring properties like 'noteId'.
 * @param data The array of objects to validate.
 * @returns `true` if valid, `false` otherwise.
 */
function isChunkOutputValid(data: any[]): boolean {
  if (!Array.isArray(data)) return false;

  for (const item of data) {
    if (typeof item !== 'object' || item === null) return false;

    for (const key in item) {
      // We only care about the generated string values.
      // 'noteId' is a number and is not generated by the AI, so we can skip it.
      if (key !== 'noteId' && typeof item[key] === 'string' && item[key].trim() === '') {
        // Found an empty string, the whole chunk is invalid.
        return false;
      }
    }
  }
  
  // If we get through all items and properties without finding an empty string, it's valid.
  return true;
}

const processChunk = async (filePath: string, instructions: string, index: number): Promise<void> => {
  const content = await fs.readFile(filePath, 'utf-8');
  const prompt = buildUserPrompt(filePath, content, instructions);

  for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
    try {
      const response = await getAiCompletion(AI_SYSTEM_PROMPT, prompt);
      const output = extractJsonFromResponse(response);

      // --- NEW VALIDATION STEP ---
      if (!isChunkOutputValid(output)) {
        // This specific error message will trigger the retry mechanism.
        throw new Error('Validation failed: AI output contains empty string values.');
      }
      // --- END OF VALIDATION ---

      await writeJsonFile(path.join(DATA_DIR, `output-part-${index}.json`), output);
      return; // Success, exit the loop.
    } catch (error) {
      if (attempt < MAX_RETRIES) {
        const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred';
        logger.warn(`Attempt ${attempt}/${MAX_RETRIES} failed for ${path.basename(filePath)} (${errorMessage}). Retrying in ${RETRY_DELAY_MS}ms...`);
        await delay(RETRY_DELAY_MS);
      } else {
        // If it fails after all retries, throw the final error.
        throw error;
      }
    }
  }
};

const cleanupFiles = async (paths: string[]) => {
  for (const f of paths) await fs.remove(f);
};

const loadTracker = async (): Promise<Tracker> => {
  try {
    return await fs.readJson(TRACKER_FILE);
  } catch {
    return { processed: [], failed: [] };
  }
};

const saveTracker = async (tracker: Tracker) => {
  await writeJsonFile(TRACKER_FILE, tracker);
};

const processWithAiCmd = new Command('process-with-ai')
  .description('Process notes using Google Gemini AI')
  .addOption(new Option('--instruction <file>', 'Instruction markdown file').makeOptionMandatory())
  .addOption(new Option('--cleanup', 'Delete temporary input-part files after run.'))
  .addOption(new Option('--retry-failed', 'Only retry failed files from tracker.json'))
  .action(async (options: { instruction: string; cleanup?: boolean; retryFailed?: boolean }) => {
    try {
      validateEnv();
      const instruction = await readInstruction(options.instruction);
      const tracker = await loadTracker();

      let inputParts: string[] = [];

      if (options.retryFailed) {
        inputParts = tracker.failed.map(f => path.join(DATA_DIR, f));
        if (inputParts.length === 0) {
          logger.info('No failed files to retry.');
          return;
        }
      } else {
        const notes = await readJsonInput();
        inputParts = await splitChunks(notes);
        await fs.remove(path.join(DATA_DIR, INPUT_JSON_FILENAME));
      }

      logger.info(`Starting AI processing for ${inputParts.length} parts.`);

      for (let i = 0; i < inputParts.length; i++) {
        const file = inputParts[i];
        const fileName = path.basename(file);

        if (!options.retryFailed && tracker.processed.includes(fileName)) {
          logger.info(`[SKIP] Already processed ${fileName}`);
          continue;
        }

        let spinnerIndex = 0;
        const spinner = spinners.dots;
        const spinnerMessage = `Processing ${fileName} (part ${i + 1}/${inputParts.length})...`;

        const spinnerInterval = setInterval(() => {
          process.stdout.write(`\r${spinner.frames[spinnerIndex = ++spinnerIndex % spinner.frames.length]} ${spinnerMessage}`);
        }, spinner.interval);

        try {
          await processChunk(file, instruction, i + 1);
          clearInterval(spinnerInterval);
          process.stdout.write(`\r${' '.repeat(spinnerMessage.length + 2)}\r${chalk.green('[OK]')} Processed ${fileName}\n`);
          if (!tracker.processed.includes(fileName)) tracker.processed.push(fileName);
          tracker.failed = tracker.failed.filter(f => f !== fileName);
        } catch (error) {
          clearInterval(spinnerInterval);
          process.stdout.write(`\r${' '.repeat(spinnerMessage.length + 2)}\r${chalk.red('[ERROR]')} Failed to process ${fileName}\n`);
          if (!tracker.failed.includes(fileName)) tracker.failed.push(fileName);
        }

        await saveTracker(tracker);
      }

      if (tracker.failed.length === 0) {
        await fs.remove(TRACKER_FILE);
      }

      if (options.cleanup && !options.retryFailed) {
        logger.info('Cleaning up temporary input-part files...');
        await cleanupFiles(inputParts);
        logger.info('Cleanup complete.');
      }

      logger.success('All parts processed.');
    } catch (err: any) {
      if (err.message.startsWith('[FAIL]')) {
        console.error(chalk.red(err.message));
      } else {
        logger.error('Process failed.');
        console.error(err);
      }
    }
  });

export default processWithAiCmd;